package dispel

import (
	"bytes"
	"fmt"
	"go/format"
	"testing"
)

func TestTemplateCompiles(t *testing.T) {
	_, err := NewTemplate(&SchemaParser{})
	ok(t, err)
}

func TestTemplateRoutes(t *testing.T) {
	schema := getSchema(t, "testdata/spells.json")
	sp := &SchemaParser{RootSchema: schema}
	routes, err := sp.ParseRoutes()
	ok(t, err)

	ctx := &TemplateContext{
		Prgm:                "dispel",
		PkgName:             "handler",
		Routes:              routes,
		HandlerReceiverType: "App",
		ExistingHandlers:    []string{},
	}

	expectedOut, err := format.Source([]byte(fmt.Sprintf(`// generated by %s; DO NOT EDIT

package %s

import (
    "net/url"
)

type routeRegisterer interface {
    RegisterRoute(path string, name string)
}

type routeReverser interface {
    ReverseRoute(name string, params ...string) *url.URL 
}

type routeReverse struct {
    R routeReverser
}

// registerRoutes uses rr to register the routes by path and name.
func registerRoutes(rr routeRegisterer) {
    rr.RegisterRoute("/spells", routeSpells)
    rr.RegisterRoute("/spells/{spell-name}", routeSpellsOne)
}

func (rr *routeReverse) Spells() *url.URL {
    return rr.R.ReverseRoute(routeSpells)
}
func (rr *routeReverse) SpellsOne(spellName string) *url.URL {
    return rr.R.ReverseRoute(routeSpellsOne, "spell-name", spellName)
}

const (
    routeSpells = "spells"
    routeSpellsOne = "spells.one"
)

`, ctx.Prgm, ctx.PkgName)))
	ok(t, err)

	tmpl, err := NewTemplate(sp)
	ok(t, err)

	var buf bytes.Buffer
	ok(t, tmpl.ExecuteTemplate(&buf, "routes", ctx))
	out, err := format.Source(buf.Bytes())
	ok(t, err)
	equals(t, string(expectedOut), string(out))
}

func TestTemplateHandlers(t *testing.T) {
	schema := getSchema(t, "testdata/spells.json")
	sp := &SchemaParser{RootSchema: schema}
	routes, err := sp.ParseRoutes()
	ok(t, err)

	ctx := &TemplateContext{
		Prgm:                "dispel",
		PkgName:             "handler",
		Routes:              routes,
		HandlerReceiverType: "*App",
		ExistingHandlers:    []string{},
	}

	expectedOut, err := format.Source([]byte(fmt.Sprintf(`// generated by %s; DO NOT EDIT

package %s

import (
	"net/http"
)

type handlerRegisterer interface {
	RegisterHandler(routeName string, handler http.Handler)
}

type routeParamGetter interface {
	GetRouteParam(w http.ResponseWriter, r *http.Request, name string) (string, error)
}

type httpEncoder interface {
    Encode(http.ResponseWriter, *http.Request, interface{}) error
}

type httpDecoder interface {
    Decode(http.ResponseWriter, *http.Request, interface{}) error
}

type errorHTTPHandlerFunc func(http.ResponseWriter, *http.Request) (int, error)

// registerHandlers registers resource handlers for each unique named route.
func registerHandlers(hr handlerRegisterer, rpg routeParamGetter, a *App, hd httpDecoder, he httpEncoder, ehhf func(errorHTTPHandlerFunc) http.handler) {
	hr(routeSpells, &MethodHandler{
		Get: ehhf(func(w http.ResponseWriter, r *http.Request) (int, error) {
			status, vresp, err := a.getSpells(w, r)
			if err != nil {
				return status, err
			}
			return status, he.Encode(w, r, vresp)
		}),
		Post: ehhf(func(w http.ResponseWriter, r *http.Request) (int, error) {
			var vreq Spell
			if err := hd.Decode(w, r, &vreq); err != nil {
				return http.StatusBadRequest, err
			}
			status, vresp, err := a.postSpells(w, r, &vreq)
			if err != nil {
				return status, err
			}
			return status, he.Encode(w, r, vresp)
		}),
	})
	hr(routeSpellsOne, &MethodHandler{
		Get: ehhf(func(w http.ResponseWriter, r *http.Request) (int, error) {
			spellName, err := rpg(w, r, "spell-name")
			if err != nil {
				return http.StatusBadRequest, err
			}
			status, vresp, err := a.getSpellsOne(w, r, spellName)
			if err != nil {
				return status, err
			}
			return status, he.Encode(w, r, vresp)
		}),
	})
}`, ctx.Prgm, ctx.PkgName)))
	ok(t, err)

	tmpl, err := NewTemplate(sp)
	ok(t, err)

	var buf bytes.Buffer
	ok(t, tmpl.ExecuteTemplate(&buf, "handlers", ctx))
	out, err := format.Source(buf.Bytes())
	if err != nil {
		t.Logf(buf.String())
		ok(t, err)
	}
	equals(t, string(expectedOut), string(out))
}

func TestTemplateHandlerFuncs(t *testing.T) {
	schema := getSchema(t, "testdata/spells.json")
	sp := &SchemaParser{RootSchema: schema}
	routes, err := sp.ParseRoutes()
	ok(t, err)

	ctx := &TemplateContext{
		Prgm:                "dispel",
		PkgName:             "handler",
		Routes:              routes,
		HandlerReceiverType: "*App",
		ExistingHandlers:    []string{},
	}

	expectedOut, err := format.Source([]byte(fmt.Sprintf(`// generated by %s; DO NOT EDIT

package %s

import (
    "net/http"
)

func (a *App) getSpells(w http.ResponseWriter, r *http.Request) (int, ListSpellOut, error) {
    return http.StatusNotImplemented, nil, nil
}

func (a *App) postSpells(w http.ResponseWriter, r *http.Request, vreq *Spell) (int, *Spell, error) {
    return http.StatusNotImplemented, nil, nil
}

func (a *App) getSpellsOne(w http.ResponseWriter, r *http.Request, spellName string) (int, *Spell, error) {
    return http.StatusNotImplemented, nil, nil
}

`, ctx.Prgm, ctx.PkgName)))
	ok(t, err)

	tmpl, err := NewTemplate(sp)
	ok(t, err)

	var buf bytes.Buffer
	ok(t, tmpl.ExecuteTemplate(&buf, "handlerfuncs", ctx))
	out, err := format.Source(buf.Bytes())
	if err != nil {
		t.Logf(buf.String())
		ok(t, err)
	}
	equals(t, string(expectedOut), string(out))
}

func TestTemplateTypesOneResource(t *testing.T) {
	schema := getSchema(t, "testdata/spells.json")
	sp := &SchemaParser{RootSchema: schema}
	routes, err := sp.ParseRoutes()
	ok(t, err)

	ctx := &TemplateContext{
		Prgm:                "dispel",
		PkgName:             "handler",
		Routes:              routes,
		HandlerReceiverType: "*App",
		ExistingHandlers:    []string{},
	}

	expectedOut, err := format.Source([]byte(fmt.Sprintf(`// generated by %s; DO NOT EDIT

package %s

type ListSpellOut []Spell

type Spell struct {
    All bool     `+"`"+`json:"all"`+"`"+`
    Element string `+"`"+`json:"element"`+"`"+`
    Name string    `+"`"+`json:"name"`+"`"+`
    Power int   `+"`"+`json:"power"`+"`"+`
}
`, ctx.Prgm, ctx.PkgName)))
	ok(t, err)

	tmpl, err := NewTemplate(sp)
	ok(t, err)

	var buf bytes.Buffer
	ok(t, tmpl.ExecuteTemplate(&buf, "types", ctx))
	out, err := format.Source(buf.Bytes())
	if err != nil {
		t.Logf(buf.String())
		ok(t, err)
	}
	equals(t, string(expectedOut), string(out))
}

func TestTemplateTypesCompositeResources(t *testing.T) {
	schema := getSchema(t, "testdata/rpg.json")
	sp := &SchemaParser{RootSchema: schema}
	routes, err := sp.ParseRoutes()
	ok(t, err)

	ctx := &TemplateContext{
		Prgm:                "dispel",
		PkgName:             "handler",
		Routes:              routes,
		HandlerReceiverType: "*App",
		ExistingHandlers:    []string{},
	}

	expectedOut, err := format.Source([]byte(fmt.Sprintf(`// generated by %s; DO NOT EDIT

package %s

type Character struct {
    Level int   `+"`"+`json:"level"`+"`"+`
    Name string    `+"`"+`json:"name"`+"`"+`
    Spells CharacterSpells   `+"`"+`json:"spells"`+"`"+`
}

type CharacterSpells []Spell

type CreateCharacterIn struct {
    Name string    `+"`"+`json:"name"`+"`"+`
}

type ListCharacterOut []ListCharacterOutOne

type ListCharacterOutOne struct {
    Level int   `+"`"+`json:"level"`+"`"+`
    Name string    `+"`"+`json:"name"`+"`"+`
}

type ListSpellOut []Spell

type Spell struct {
    Element string `+"`"+`json:"element"`+"`"+`
    Name string    `+"`"+`json:"name"`+"`"+`
    Power int   `+"`"+`json:"power"`+"`"+`
}

`, ctx.Prgm, ctx.PkgName)))
	ok(t, err)

	tmpl, err := NewTemplate(sp)
	ok(t, err)

	var buf bytes.Buffer
	ok(t, tmpl.ExecuteTemplate(&buf, "types", ctx))
	out, err := format.Source(buf.Bytes())
	if err != nil {
		t.Logf(buf.String())
		ok(t, err)
	}
	equals(t, string(expectedOut), string(out))
}
