package main

import (
	"bytes"
	"encoding/json"
	"flag"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"io/ioutil"
	"log"
	"net/url"
	"os"
	"path/filepath"
	"regexp"
	"sort"
	"strings"
	"text/template"
	"unicode"
	"unicode/utf8"
)

const routesTmpl = `// generated by {{ .Prgm }}; DO NOT EDIT

package {{ .PkgName }}

import (
	"net/url"
)

// setupRoutes registers the url path and name of all routes of the API.
func (r *Routes) setupRoutes() {
{{ range .Routes }}	r.r.Path("{{ .Path }}").Name("{{ .Name }}")
{{end}}}

// URL builders

{{ range .Routes }}func (r *Routes) {{ .FuncBaseName | capitalize }}({{ range .RouteParams }}{{ .Varname }} string,{{end}}) *url.URL {
	return r.routeURL("{{ .Name }}", {{ range .RouteParams }}"{{ .Name }}", {{ .Varname }},{{end}})
}
{{end}}`

const handlersTmpl = `// generated by {{ .Prgm }}; DO NOT EDIT

package {{ .PkgName }}

import (
	"net/http"
)

// registerAPIHandlers registers resource handlers for each unique named route of the API.
func (h *Handler) registerAPIHandlers() {
{{ range .Routes }}	h.Routes.r.Get("{{ .Name }}").Handler(&MethodHandler{
{{ $route := . }}{{ range .Methods }}	{{ . | tolower | capitalize }}: endpointHandler(func(w http.ResponseWriter, r *http.Request) *endpointError {
        {{ range $route.RouteParams }}{{ .Varname }}, err := h.getUID(w, r, "{{ .Name }}")
	if err != nil {
		return newEndpointError(err, http.StatusBadRequest)
	}
	{{end}}	return h.{{ . | tolower }}{{ $route.FuncBaseName }}(w, r{{ range $route.RouteParams }},{{ .Varname }}{{end}})
}),
{{end}}
})
{{end}}}`

const handlerFuncsTmpl = `// generated by {{ .Prgm }}; DO NOT EDIT

package {{ .PkgName }}

import (
	"net/http"
)

{{ range .Routes }}{{ $route := . }}{{ range .Methods }}{{ $lmethod := . | tolower }}{{ with $funcName := printf "%s%s" $lmethod $route.FuncBaseName }}{{ if handlerFuncMissing $funcName }}func (h *Handler) {{ $funcName }}(w http.ResponseWriter, r *http.Request{{ range $route.RouteParams }}, {{ .Varname }} string{{end}}) *endpointError {
	http.Error(w, http.StatusText(http.StatusNotImplemented), http.StatusNotImplemented)
	return nil
}

{{end}}{{end}}{{end}}{{end}}`

var genTypes = map[string]string{
	"routes":       routesTmpl,
	"handlers":     handlersTmpl,
	"handlerfuncs": handlerFuncsTmpl,
}

func init() {
	flag.StringVar(&schemaFilepath, "schema", "", "JSON Schema file name (relative to this file's dir)")
	genTypeNames := make([]string, 0, 2)
	for name := range genTypes {
		genTypeNames = append(genTypeNames, name)
	}
	flag.StringVar(&genType, "type", "", fmt.Sprintf("the type of code to generate. One of %s", strings.Join(genTypeNames, "|")))
	flag.BoolVar(&noGofmt, "no-gofmt", false, "do not run gofmt on the source")
}

var (
	schemaFilepath string
	genType        string
	noGofmt        bool
)

// Schema represents a JSON Schema.
type Schema struct {
	ID          string `json:"id,omitempty"`
	Title       string `json:"title,omitempty"`
	Description string `json:"description,omitempty"`
	Version     string `json:"version,omitempty"`

	Default  interface{} `json:"default,omitempty"`
	ReadOnly bool        `json:"readOnly,omitempty"`
	Example  interface{} `json:"example,omitempty"`
	Format   string      `json:"format,omitempty"`

	Type interface{} `json:"type,omitempty"`

	Ref    string `json:"$ref,omitempty"`
	Schema string `json:"$schema,omitempty"`

	Definitions map[string]*Schema `json:"definitions,omitempty"`

	// Numbers
	MultipleOf       float64 `json:"multipleOf,omitempty"`
	Maximum          float64 `json:"maximum,omitempty"`
	ExclusiveMaximum bool    `json:"exclusiveMaximum,omitempty"`
	Minimum          float64 `json:"minimum,omitempty"`
	ExclusiveMinimum bool    `json:"exclusiveMinimum,omitempty"`

	// Strings
	MinLength int    `json:"minLength,omitempty"`
	MaxLength int    `json:"maxLength,omitempty"`
	Pattern   string `json:"pattern,omitempty"`

	// Objects
	MinProperties        int                    `json:"minProperties,omitempty"`
	MaxProperties        int                    `json:"maxProperties,omitempty"`
	Required             []string               `json:"required,omitempty"`
	Properties           map[string]*Schema     `json:"properties,omitempty"`
	Dependencies         map[string]interface{} `json:"dependencies,omitempty"`
	AdditionalProperties interface{}            `json:"additionalProperties,omitempty"`
	PatternProperties    map[string]*Schema     `json:"patternProperties,omitempty"`

	// Arrays
	Items           *Schema     `json:"items,omitempty"`
	MinItems        int         `json:"minItems,omitempty"`
	MaxItems        int         `json:"maxItems,omitempty"`
	UniqueItems     bool        `json:"uniqueItems,omitempty"`
	AdditionalItems interface{} `json:"additionalItems,omitempty"`

	// All
	Enum []string `json:"enum,omitempty"`

	// Schemas
	OneOf []Schema `json:"oneOf,omitempty"`
	AnyOf []Schema `json:"anyOf,omitempty"`
	AllOf []Schema `json:"allOf,omitempty"`
	Not   *Schema  `json:"not,omitempty"`

	// Links
	Links []Link `json:"links,omitempty"`
}

// Link represents a Link description.
type Link struct {
	Title        string  `json:"title,omitempty"`
	Description  string  `json:"description,omitempty"`
	HRef         string  `json:"href,omitempty"`
	Rel          string  `json:"rel,omitempty"`
	Method       string  `json:"method,omitempty"`
	Schema       *Schema `json:"schema,omitempty"`
	TargetSchema *Schema `json:"targetSchema,omitempty"`
}

type route struct {
	Path         string
	Name         string
	RouteParams  []routeParam
	Methods      methods
	FuncBaseName string
}

type routeParam struct {
	Name    string
	Varname string
}

type routes []route

func (r routes) Len() int           { return len(r) }
func (r routes) Swap(i, j int)      { r[i], r[j] = r[j], r[i] }
func (r routes) Less(i, j int) bool { return r[i].Path < r[j].Path }

type methods []string

func (m methods) Len() int      { return len(m) }
func (m methods) Swap(i, j int) { m[i], m[j] = m[j], m[i] }
func (m methods) Less(i, j int) bool {
	var (
		ii = -1
		ji = -1
	)
	for k, um := range methodsOrder {
		if strings.ToUpper(m[i]) == um {
			ii = k
		}
		if strings.ToUpper(m[j]) == um {
			ji = k
		}
		if ii > -1 && ji > -1 {
			break
		}
	}
	return ii < ji
}

var methodsOrder = []string{"GET", "HEAD", "POST", "PUT", "PATCH", "DELETE", "OPTIONS"}

func href2path(s string) string {
	p := refPattern.ReplaceAllStringFunc(s, func(m string) string {
		// Unescape string
		m, err := url.QueryUnescape(m)
		if err != nil {
			panic(err)
		}
		m = strings.Replace(m, "#/definitions/", "", 1)
		m = strings.Replace(m, "/definitions/", "-", -1)
		return "{" + m[2:len(m)-2] + "}"
	})
	return p
}

func routeParamsFromPath(s string) []routeParam {
	var (
		inVar       bool
		varbuf      bytes.Buffer
		routeParams []routeParam
	)
	for _, r := range s {
		if r == '{' {
			if inVar {
				panic("found opening { while already in var")
			}
			inVar = true
			continue
		}
		if r == '}' {
			inVar = false
			routeParams = append(routeParams, routeParam{
				Name:    varbuf.String(),
				Varname: strings.Replace(afterRuneUpper(varbuf.String(), "-"), "Uid", "UID", 1),
			})
			varbuf.Reset()
			continue
		}
		if inVar {
			varbuf.WriteRune(r)
		}
	}
	return routeParams
}

func href2name(s string) string {
	name := refPattern.ReplaceAllString(s, "self")
	name = strings.Replace(name, "/", ".", -1)
	return name[1:]
}

func capitalize(s string) string {
	r, size := utf8.DecodeRuneInString(s)
	return fmt.Sprintf("%c%s", unicode.ToUpper(r), s[size:])
}

func afterRuneUpper(s string, chars string) string {
	var buf bytes.Buffer
	var upnext bool
OuterLoop:
	for _, r := range s {
		for _, c := range chars {
			if r == c {
				upnext = true
				continue OuterLoop
			}
		}
		if upnext {
			buf.WriteRune(unicode.ToUpper(r))
			upnext = false
			continue
		}
		buf.WriteRune(r)
	}
	return buf.String()
}

var refPattern = regexp.MustCompile(`{\([^/]+\)}`)

// walker adapts a function to satisfy the ast.Visitor interface.
// The function return whether the walk should proceed into the node's children.
type walker func(ast.Node) bool

func (w walker) Visit(node ast.Node) ast.Visitor {
	if w(node) {
		return w
	}
	return nil
}

func main() {
	flag.Parse()
	prgmName := filepath.Base(os.Args[0])
	log.SetFlags(0)
	log.SetPrefix(prgmName + ": ")

	// Check envvars from go:generate are set
	goPkgName := os.Getenv("GOPACKAGE")
	goFileName := os.Getenv("GOFILE")
	if goPkgName == "" {
		log.Fatal("$GOPACKAGE is empty")
	}
	if goFileName == "" {
		log.Fatal("$GOFILE is empty")
	}
	absGoFileName, err := filepath.Abs(goFileName)
	if err != nil {
		log.Fatal(err)
	}

	// Setting the json schema is mandatory
	if schemaFilepath == "" {
		log.Fatal("no jsonschema file provided")
	}
	// Setting the type of code to generate is mandatory
	if genType == "" {
		log.Fatal("no type of code to generate specified")
	}
	_, ok := genTypes[genType]
	if !ok {
		log.Fatalf("%s: unknown gentype", genType)
	}

	// name of the generated file
	dotIndex := strings.LastIndex(goFileName, ".go")
	if dotIndex == -1 {
		log.Fatalf("%s: not a .go file", goFileName)
	}
	genFileName := fmt.Sprintf("%s.gen.%s.go", goFileName[:dotIndex], genType)
	genPath := filepath.Join(filepath.Dir(absGoFileName), genFileName)

	f, err := os.Open(filepath.Clean(filepath.Join(filepath.Dir(absGoFileName), schemaFilepath)))
	if err != nil {
		log.Fatal(err)
	}

	var schema Schema
	if err := json.NewDecoder(f).Decode(&schema); err != nil {
		f.Close()
		log.Fatal(err)
	}
	f.Close()

	// Analyse AST of handler package, look for *Handler methods.
	// However, we exclude the ones we generated previously.
	fset := token.NewFileSet()
	pkgs, err := parser.ParseDir(fset, filepath.Dir(goFileName), func(fi os.FileInfo) bool {
		return fi.Name() != genFileName
	}, parser.ParseComments)
	if err != nil {
		log.Fatal(err)
	}
	handlerPkg, ok := pkgs["handler"]
	if !ok {
		log.Fatalf("%s: package not found in %q", "handler", filepath.Dir(goFileName))
	}

	handlerFuncNames := make([]string, 0, 200)
	for _, astFile := range handlerPkg.Files {
		ast.Walk(walker(func(node ast.Node) bool {
			switch v := node.(type) {
			case *ast.FuncDecl:
				if v.Recv != nil {
					// this is a method, find the type of the receiver
					field := v.Recv.List[0]
					se, ok := field.Type.(*ast.StarExpr)
					if !ok {
						return true
					}
					ident, ok := se.X.(*ast.Ident)
					if !ok {
						return true
					}
					if ident.Name != "Handler" {
						return true
					}
					handlerFuncNames = append(handlerFuncNames, v.Name.String())
				}
			}
			return true
		}), astFile)
	}

	// Compile template
	t := template.New("").Funcs(template.FuncMap{
		"tolower":    strings.ToLower,
		"capitalize": capitalize,
		"symbolName": func(s string) string {
			return afterRuneUpper(s, ".- ")
		},
		"handlerFuncMissing": func(s string) bool {
			for _, handlerFuncName := range handlerFuncNames {
				if s == handlerFuncName {
					return false
				}
			}
			return true

		},
	})
	for name, tmpl := range genTypes {
		var err error
		t, err = t.New(name).Parse(tmpl)
		if err != nil {
			log.Fatalf("template %s: %v", name, err)
		}
	}

	// Prepare context for template
	// Note: we use the same context for all types of templates
	ctx := struct {
		Prgm    string
		PkgName string
		Routes  routes
	}{
		Prgm:    strings.Join(append([]string{prgmName}, os.Args[1:]...), " "),
		PkgName: goPkgName,
	}

	pathRouteMap := make(map[string]*route, len(schema.Definitions)*4)
	for _, definition := range schema.Definitions {
		for _, link := range definition.Links {
			p := href2path(link.HRef)
			r, ok := pathRouteMap[p]
			if !ok {
				name := href2name(link.HRef)
				r = &route{
					Path:         p,
					Name:         name,
					FuncBaseName: capitalize(afterRuneUpper(name, ".-")),
					RouteParams:  routeParamsFromPath(p),
				}
				pathRouteMap[p] = r
			}
			r.Methods = append(r.Methods, link.Method)
			sort.Sort(r.Methods)
		}
	}
	for _, r := range pathRouteMap {
		ctx.Routes = append(ctx.Routes, *r)
	}
	sort.Sort(ctx.Routes)

	// Exec template
	var buf bytes.Buffer
	tmpl := t.Lookup(genType)
	if err := tmpl.Execute(&buf, ctx); err != nil {
		log.Fatal(err)
	}

	// Format source with gofmt
	var src []byte
	if noGofmt {
		src = buf.Bytes()
	} else {
		src, err = format.Source(buf.Bytes())
		if err != nil {
			log.Fatalf("%s\n\ngofmt: %s", buf.Bytes(), err)
		}
	}

	// Write file to disk
	if err := ioutil.WriteFile(genPath, src, 0666); err != nil {
		log.Fatal(err)
	}
}
