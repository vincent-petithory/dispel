// generated by {{ .Prgm }}; DO NOT EDIT

package {{ .PkgName }}

import (
	"net/http"
)

type handlerRegisterer interface {
    RegisterHandler(routeName string, handler http.Handler)
}

type routeParamGetter interface {
    GetRouteParam(w http.ResponseWriter, r *http.Request, name string) (string, error)
}

type httpEncoder interface {
    Encode(http.ResponseWriter, *http.Request, interface{}) error
}

type httpDecoder interface {
    Decode(http.ResponseWriter, *http.Request, interface{}) error
}

type errorHTTPHandlerFunc func (http.ResponseWriter, *http.Request) (int, error)

// registerHandlers registers resource handlers for each unique named route.{{ $handlerReceiverType := .HandlerReceiverType }}
func registerHandlers(hr handlerRegisterer, rpg routeParamGetter, {{ varname $handlerReceiverType}} {{ $handlerReceiverType }}, hd httpDecoder, he httpEncoder, ehhf func(errorHTTPHandlerFunc) http.handler) {
{{ range .Routes.ByResource }}    hr(route{{ symbolName .Name }}, &MethodHandler{
{{ $route := . }}{{ range .Methods }}	{{ . | tolower | capitalize }}: ehhf(func(w http.ResponseWriter, r *http.Request) (int, error) {
    {{/*
Get route params first, if any
*/}}{{ range $route.RouteParams }}{{ .Varname }}, err := rpg(w, r, "{{ .Name }}")
	if err != nil {
		return http.StatusBadRequest, err
        }
	{{end}}{{/*
Decode request body if any expected
*/}}{{ $io := index $route.MethodRouteIOMap . }}{{ if $io.InType }}var vreq {{ printTypeName $io.InType }}
	if err := hd.Decode(w, r, &vreq); err != nil {
            return http.StatusBadRequest, err
        }
	{{ end }}status{{ if $io.OutType }}, vresp{{end}}, err := {{ varname $handlerReceiverType}}.{{ . | tolower }}{{ $route.Name | symbolName }}(w, r{{/*
Route params and I/O types
*/}}{{ range $route.RouteParams }}, {{ .Varname }}{{end}}{{ if $io.InType }}, &vreq{{end}})
        if err != nil {
            return status, err
        }
        return status, he.Encode(w, r, vresp)
}),
{{end}}
})
{{end}}}
