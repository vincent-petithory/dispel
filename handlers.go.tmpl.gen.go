// AUTOMATICALLY GENERATED FILE. DO NOT EDIT.

package dispel

var handlersTmpl = tmpl(asset.init(asset{Name: "handlers.go.tmpl", Content: "" +
	"// generated by {{ .Prgm }}; DO NOT EDIT\n\npackage {{ .PkgName }}\n\nimport (\n\t\"errors\"\n\t\"net/http\"\n)\n\n// HandlerRegisterer is the interface implemented by objects that can register a http handler\n// for an http route.\ntype HandlerRegisterer interface {\n    RegisterHandler(routeName string, handler http.Handler)\n}\n\n// registerHandlerFunc is an adapter to use funcs as HandlerRegisterer. \ntype registerHandlerFunc func(routeName string, handler http.Handler)\n\n// RegisterHandler calls f(routeName, handler).\nfunc (f registerHandlerFunc) RegisterHandler(routeName string, handler http.Handler) {\n\tf(routeName, handler)\n}\n\n// RouteParamGetter is the interface implemented by objects that can retrieve\n// the value of a parameter of a route, by name.\ntype RouteParamGetter interface {\n    GetRouteParam(r *http.Request, name string) string\n}\n\n// HTTPEncoder is the interface implemented by objects that can encode values to a http response,\n// with the specified http status.\n//\n// Implementors must handle nil data.\ntype HTTPEncoder interface {\n    Encode(w http.ResponseWriter, r *http.Request, data interface{}, code int) error\n}\n\n// HTTPDecoder is the interface implemented by objects that can decode data received from a http request.\n//\n// Implementors have to close the request.Body.\n// Decode() shouldn't write to http.ResponseWriter: it's up to the caller to e.g, handle errors.\ntype HTTPDecoder interface {\n    Decode(http.ResponseWriter, *http.Request, interface{}) error\n}\n\n// errorHTTPHandlerFunc defines the signature of the generated http handlers used in registerHandlers().\n//\n// The basic contract of this handler is it write the status code to w (and the body, if any), unless an error is returned;\n// in this case, the caller has to write to w.\ntype errorHTTPHandlerFunc func (w http.ResponseWriter, r *http.Request) (status int, err error)\n\n// registerHandlers registers resource handlers for each unique named route.\n// registerHandlers must be called after the registerRoutes().\n{{ $handlerReceiverType := .HandlerReceiverType }}func registerHandlers(hr HandlerRegisterer, rpg RouteParamGetter, {{ varname $handlerReceiverType}} {{ $handlerReceiverType }}, hd HTTPDecoder, he HTTPEncoder, ehhf func(errorHTTPHandlerFunc) http.Handler) {\n{{ range .Routes.ByResource }}    hr.RegisterHandler(route{{ symbolName .Name }}, &MethodHandler{\n{{ $route := . }}{{ range .Methods }}\t{{ . | tolower | capitalize }}: ehhf(func(w http.ResponseWriter, r *http.Request) (int, error) {\n    {{/*\nGet route params first, if any\n*/}}{{ range $route.RouteParams }}{{ .Varname }} := rpg.GetRouteParam(r, \"{{ .Name }}\")\n\tif {{ .Varname }} == \"\" {\n\t\treturn http.StatusBadRequest, errors.New(\"empty route parameter \\\"{{ .Name }}\\\"\")\n        }\n\t{{end}}{{/*\nDecode request body if any expected\n*/}}{{ $io := index $route.MethodRouteIOMap . }}{{ if $io.InType }}var vreq {{ printTypeName $io.InType }}\n\tif err := hd.Decode(w, r, &vreq); err != nil {\n            return http.StatusBadRequest, err\n        }\n\t{{ end }}status{{ if $io.OutType }}, vresp{{end}}, err := {{ varname $handlerReceiverType}}.{{ . | tolower }}{{ $route.Name | symbolName }}(w, r{{/*\nRoute params and I/O types\n*/}}{{ range $route.RouteParams }}, {{ .Varname }}{{end}}{{ if $io.InType }}, &vreq{{end}})\n        if err != nil {\n            return status, err\n        }\n        return status, he.Encode(w, r, {{ if $io.OutType }}vresp,{{ else }}nil,{{end}} status)\n}),\n{{end}}\n})\n{{end}}}\n" +
	""}))
