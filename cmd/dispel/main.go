package main

import (
	"bytes"
	"encoding/json"
	"flag"
	"fmt"
	"go/format"
	"io"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"strings"

	"github.com/vincent-petithory/dispel"
)

var (
	templateNameList    string
	defaultImplNameList string
	prefix              string
	handlerReceiverType string
	pkgpath             string
	pkgname             string
	altFormatPath       string
	verbose             bool
)

func init() {
	flag.StringVar(&templateNameList, "t", "", "")
	flag.StringVar(&defaultImplNameList, "d", "", "")
	flag.StringVar(&prefix, "p", "dispel_", "")
	flag.StringVar(&handlerReceiverType, "hrt", "", "")
	flag.StringVar(&pkgpath, "pp", "", "")
	flag.StringVar(&pkgname, "pn", "", "")
	flag.StringVar(&altFormatPath, "f", "", "")
	flag.BoolVar(&verbose, "v", false, "")
	flag.Usage = func() {
		fmt.Fprintln(os.Stderr, "usage: dispel [-t names] [-d names] [-p prefix] [-hrt typename] [-pp packagepath] [-pn packagename] [-f path] [-v] SCHEMA")
		fmt.Fprintln(os.Stderr)
		usage(os.Stderr)
	}
}

func usage(w io.Writer) {
	fmt.Fprintf(w, `dispel generates source code based on a JSON Hyper-Schema for quickly building REST APIs in Go.

The dispel command requires a unique argument, SCHEMA, which is the path to the JSON Hyper-Schema.

dispel is best used in conjunction with go:generate, by making use of $GOPACKAGE and $GOFILE envvars.

FLAGS

The -v flag makes dispel more verbose about what the entities it discovers while parsing the json schema.

The -t flag specifies which templates to execute, with a comma-separated list of template names.
The names must be in the following list:

%s

If empty (the default), none is executed. If set to the special value all, all known templates are executed.
dispel will write a file in the package dir (see -pp flag) for each name provided with a filename using the pattern {prefix}{name}.go, where prefix is defined by the -p flag.

The -d flag specifies which default implementations provided by dispel to execute,
like -t, using a comma-separated list of default implementation names.
The names must be in the following list:

%s

If empty (the default), none is executed. If set to the special value all, all default implementations are executed.
dispel will write a file in the package dir (see -pp flag) for each default implementation
with a filename using the pattern {impl-name}.go

The -p flag specifies which prefix to use for each generated template file. By default, it is set to 'dispel_'.
This doesn't apply to default implementations, which have fixed names.

The -hrt flag specifies the Go type in the target package which
will be the receiver for the handler functions dispel generates.
For example, with a value of *AppHandlers, dispel will generate something like:

    func (ah *AppHandlers) getUsers(w http.ResponseWriter, r *http.Request, ....


The -pp flag specifies which package dir to generate and analyze code into.
It is mandatory to set this flag if dispel is not invoked with go:generate.
If set when dispel is invoked with go:generate, it overrides the package path resolved from $GOFILE.

The -pn flag specifies the package name of the code generated by dispel.
It is mandatory to set a value if not invoked with go:generate.
If set when dispel is invoked with go:generate, it overrides the value of $GOPACKAGE.

The -f flag specifies the path to the file for an alternate format for the template to use, using the Go template syntax.
If the value is -, then the template is read from STDIN.
If set, then -t and -d flags are ignored: only this template is executed. The result is printed to STDOUT.

The context passed to the template is TemplateContext.

TEMPLATE CONTEXT

The following struct is passed to the templates:

    type TemplateContext struct {
        Prgm                string   // name of the program generating the source
        PkgName             string   // package name for which source code is generated
        Routes              Routes   // routes parsed by the SchemaParser
        HandlerReceiverType string   // type which acts as the receiver of the handler funcs.
        ExistingHandlers    []string // list of existing handler funcs in the target package, with HandlerReceiverType as the receiver
        ExistingTypes       []string // list of existing types in the target package.
    }

The template has those functions available:

 * tolower            : calls strings.ToLower
 * capitalize         : uppercase the first rune of a string
 * symbolName         : uppercase each rune following one of ".- ", then uppercase the first rune 
 * hasItem            : takes 2 arguments: ([]string, string); returns true if string is one of the elements of []string
 * varname            : creates a short variable name from a type. e.g MyLongType would return mlt
 * printTypeDef       : prints a valid Go type from a JSONType
 * printTypeName      : prints the name of the Go type for a JSONType
 * printSmartDerefType: is like printTypeName, but if the argument is a JSONObject, it return *TheType instead of TheType.

For more information, see the documentation of the github.com/vincent-petithory/dispel package's TemplateContext type.

`,
		"    "+strings.Join(dispel.TemplateNames(), "\n    "),
		"    "+strings.Join(dispel.DefaultImplNames(), "\n    "),
	)
}

// NewSchemaParser creates a new SchemaParser for the json schema at path.
func NewSchemaParser(path string) (*dispel.SchemaParser, error) {
	f, err := os.Open(path)
	if err != nil {
		return nil, err
	}
	defer func() {
		_ = f.Close()
	}()

	var schema dispel.Schema
	if err := json.NewDecoder(f).Decode(&schema); err != nil {
		return nil, err
	}

	return &dispel.SchemaParser{RootSchema: &schema}, nil
}

func main() {
	flag.Parse()
	prgmName := filepath.Base(os.Args[0])
	log.SetFlags(0)
	log.SetPrefix(prgmName + ": ")

	// Check envvars from go:generate are set
	var pkgAbsPath string
	switch {
	case pkgpath != "":
		p, err := filepath.Abs(pkgpath)
		if err != nil {
			log.Fatal(err)
		}
		pkgAbsPath = p
	case os.Getenv("GOFILE") != "":
		p, err := filepath.Abs(os.Getenv("GOFILE"))
		if err != nil {
			log.Fatal(err)
		}
		pkgAbsPath = filepath.Dir(p)
	default:
		flag.Usage()
		log.Fatal("no package found: $GOFILE or --pkgpath must be set")
	}
	switch {
	case pkgname != "":
	case os.Getenv("GOPACKAGE") != "":
		pkgname = os.Getenv("GOPACKAGE")
	default:
		flag.Usage()
		log.Fatal("no package name found: $GOPACKAGE or --pkgname must be set")
	}

	// Abort if the generated files' prefix is empty
	if prefix == "" {
		flag.Usage()
		log.Fatal("generated files need a non-empty prefix")
	}

	// Setting the json schema path is mandatory
	if flag.NArg() < 1 {
		flag.Usage()
		log.Fatal("no jsonschema file provided")
	}
	schemaFilepath := flag.Arg(0)

	// Split comma-separated lists of templates/default impls
	templateNames := strings.Split(templateNameList, ",")
	for i := range templateNames {
		templateNames[i] = strings.TrimSpace(templateNames[i])
	}
	defaultImplNames := strings.Split(defaultImplNameList, ",")
	for i := range defaultImplNames {
		defaultImplNames[i] = strings.TrimSpace(defaultImplNames[i])
	}

	// Parse JSON Schema
	schemaParser, err := NewSchemaParser(schemaFilepath)
	if err != nil {
		log.Fatal(err)
	}
	if verbose {
		schemaParser.Log = log.New(os.Stdout, "dispel> ", 0)
	}

	// Create dispel template using the parser
	t, err := dispel.NewTemplateBundle(schemaParser)
	if err != nil {
		log.Fatal(err)
	}

	// Create the list of generated file names
	genPathFn := func(name string) string {
		return filepath.Join(pkgAbsPath, fmt.Sprintf("%s%s.go", prefix, strings.ToLower(name)))
	}

	var genFilenames []string
	for _, tmplName := range t.Names() {
		genFilenames = append(genFilenames, filepath.Base(genPathFn(tmplName)))
	}

	// Find methods whose receiver's type is the one defined as holding handler funcs implementations
	// We exclude the ones we auto-generate.
	handlerFuncDecls, err := dispel.FindTypesFuncs(pkgAbsPath, pkgname, []string{strings.Replace(handlerReceiverType, "*", "", -1)}, genFilenames)
	if err != nil {
		log.Fatal(err)
	}
	var existingHandlers []string
	for name := range handlerFuncDecls {
		existingHandlers = append(existingHandlers, name)
	}
	if verbose {
		log.Printf("existing handlers: %s", strings.Join(existingHandlers, "\n --> "))
	}

	// Find types already defined in the package.
	// We exclude the ones we auto-generate.
	typeSpecs, err := dispel.FindTypes(pkgAbsPath, pkgname, genFilenames)
	if err != nil {
		log.Fatal(err)
	}
	var existingTypes []string
	for name := range typeSpecs {
		existingTypes = append(existingTypes, name)
	}
	if verbose {
		log.Printf("existing types: %s", strings.Join(existingTypes, "\n --> "))
	}

	// Parse the routes in the schema
	routes, err := schemaParser.ParseRoutes()
	if err != nil {
		switch t := err.(type) {
		case dispel.InvalidSchemaError:
			log.Fatalf("Schema: %#v\nMsg: %s", t.Schema, t.Msg)
		default:
			log.Fatal(err)
		}
	}

	// Prepare context for template
	ctx := &dispel.TemplateContext{
		Prgm:                strings.Join(append([]string{prgmName}, os.Args[1:]...), " "),
		PkgName:             pkgname,
		Routes:              routes,
		HandlerReceiverType: handlerReceiverType,
		ExistingHandlers:    existingHandlers,
		ExistingTypes:       existingTypes,
	}

	if altFormatPath != "" {
		var altFormat string
		if altFormatPath == "-" {
			b, err := ioutil.ReadAll(os.Stdin)
			if err != nil {
				log.Fatal(err)
			}
			altFormat = string(b)
		} else {
			b, err := ioutil.ReadFile(altFormatPath)
			if err != nil {
				log.Fatal(err)
			}
			altFormat = string(b)
		}
		if err := t.ExecuteCustomTemplate(os.Stdout, altFormat, ctx); err != nil {
			log.Fatal(err)
		}
		return
	}

	// Exec templates
	if len(templateNames) == 1 && templateNames[0] == "all" {
		templateNames = t.Names()
	}
	var buf bytes.Buffer
	for _, name := range templateNames {
		if name == "" {
			continue
		}
		if err := t.ExecuteTemplate(&buf, name, ctx); err != nil {
			log.Fatal(err)
		}
		// Format source with gofmt
		src, err := format.Source(buf.Bytes())
		if err != nil {
			log.Fatalf("%s\n\ngofmt: %s", buf.Bytes(), err)
		}

		// Write file to disk
		if err := ioutil.WriteFile(genPathFn(name), src, 0666); err != nil {
			log.Fatal(err)
		}
		buf.Reset()
	}

	defaultImpl, err := dispel.NewDefaultImplBundle()
	if err != nil {
		log.Fatal(err)
	}
	buf.Reset()
	if len(defaultImplNames) == 1 && defaultImplNames[0] == "all" {
		defaultImplNames = defaultImpl.Names()
	}
	for _, name := range defaultImplNames {
		if name == "" {
			continue
		}
		if err := defaultImpl.ExecuteTemplate(&buf, name, ctx.PkgName); err != nil {
			log.Fatal(err)
		}
		// Format source with gofmt
		src, err := format.Source(buf.Bytes())
		if err != nil {
			log.Fatalf("%s\n\ngofmt: %s", buf.Bytes(), err)
		}

		// Write file to disk
		destpath := filepath.Join(pkgAbsPath, name+".go")
		if err := ioutil.WriteFile(destpath, src, 0666); err != nil {
			log.Fatal(err)
		}
		buf.Reset()
	}
}
