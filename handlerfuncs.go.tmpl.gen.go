// AUTOMATICALLY GENERATED FILE. DO NOT EDIT.

package dispel

var handlerfuncsTmpl = tmpl(asset.init(asset{Name: "handlerfuncs.go.tmpl", Content: "" +
	"// generated by {{ .Prgm }}; DO NOT EDIT\n\npackage {{ .PkgName }}\n\n{{ if allHandlerFuncsImplemented .Routes .ExistingHandlers }}// No default handler func was generated, because all are implemented.\n{{ else }}import (\n\t\"net/http\"\n)\n\n{{/* Generate a function for each method+resource */}}\n{{ $handlerReceiverType := .HandlerReceiverType }}{{ $existingHandlers := .ExistingHandlers }}{{ range .Routes.ByResource }}{{ $route := . }}{{ range .Methods }}{{ $io := index $route.MethodRouteIOMap . }}{{/*\n*/}}{{ with $funcName := (handlerFuncName . $route.Name) }}{{/*\nDo not generate the handler if it's already present in the package\n*/}}{{ if not (hasItem $existingHandlers $funcName) }}{{/*\n*/}}func ({{ varname $handlerReceiverType }} {{ $handlerReceiverType }}) {{ $funcName }}(w http.ResponseWriter, r *http.Request{{ range $route.RouteParams }}, {{ .Varname }} string{{end}}{{/*\nGenerate in and out types*/}}{{ if $io.InType }}, vreq {{ printSmartDerefType $io.InType }}{{end}}) (int{{ if $io.OutType }}, {{ printSmartDerefType $io.OutType }}{{end}}, error) {\n\t{{ if $io.OutputIsNotJSON }}http.Error(w, http.StatusText(http.StatusNotImplemented), http.StatusNotImplemented)\n{{ end }}\treturn http.StatusNotImplemented{{ if $io.OutType }}, nil{{end}}, nil\n}\n\n{{end}}{{end}}{{end}}{{end}}\n{{ end }}\n" +
	""}))
